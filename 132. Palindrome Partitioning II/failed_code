/
    it is not the correct answer to the problem. althongh i had found it when coding ,i decide to finish it finally and share it. 
    it can work in most cases .
/

class Solution {
public:
    int minCut(string s) {
    
		string s2(s.rbegin(), s.rend());
		vector<string> ss = { s,s2 };
		vector<int> temp_count;
		for (size_t i = 0; i < 2; i++)
		{
			string s0 = ss[i];

			vector<vector<int>> a_nums{ {0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0} };  

			for (size_t i = 0; i < s0.length(); i++)  //build a array to describe the position of alphabet in ascending orde 
			{
				a_nums[s0[i] - 'a'].push_back(i + 1);
			}

			for (int i = 0; i < 26; i++)  // the begining is 0 . the end is int_max
			{
				a_nums[i].push_back(INT_MAX);
			}

			int begin_number = 0;
			int j = 1;
			int count_number = 0;
			vector<int> begin_flags(26, 0);
          
			int temp_max_num = s0.size();
			while (begin_number < s0.length())    // if the whole string is traversed
			{
				vector<int>  end_flags(26, 0);      
				bool flag_break = false;
				int self = s0[begin_number] - 'a';
				int min_num_addr = begin_flags[self] + 1, max_num_addr = a_nums[self].size() - 2;    // the starting point of the palindrome
				int min_num = a_nums[self][min_num_addr], max_num = a_nums[self][max_num_addr];
				string s_temp = s0.substr(max_num);
              
				cout << s_temp << endl;
				for (size_t i = max_num; i < s0.size(); i++)
				{
					end_flags[s0[i] - 'a'] = end_flags[s0[i] - 'a'] + 1;
				}

				if (max_num_addr == 0) { max_num_addr++; }
               


				while (min_num_addr <= max_num_addr)  //  judge if the string is palingrome
				{
                     vector<int> temp_begin_flags = begin_flags;
					int min_num_addr_2 = min_num_addr, max_num_addr_2 = max_num_addr;
					int min_num_2 = a_nums[self][min_num_addr_2], max_num_2 = a_nums[self][max_num_addr_2];
					double mid = (double)(min_num_2 + max_num_2) / 2, mid2 = mid;
					int ii = 0;

					if (max_num - min_num  == 1)
					{
						count_number++;
						int begin_temp = s0[begin_number] - 'a';
						char char_temp = s0[begin_number];
						begin_number = a_nums[begin_temp][max_num_addr];
						begin_flags = temp_begin_flags;
						int pos = 0;
						for (size_t iii = 0; iii < begin_number; iii++)
						{
							if (char_temp == s0[iii])
							{
								pos++;
							}
						}
						begin_flags[begin_temp] = pos;
						flag_break = true;
						break;

					}
					
					while ( ii < 26) 
					{
						min_num_2 = a_nums[ii][begin_flags[ii] + j];
						max_num_2 = a_nums[ii][a_nums[ii].size() - end_flags[ii] - j -1 ];
						j++;

		                 if (a_nums[ii].size() == 2 || max_num_2 == INT_MAX)
						 {
							j = 1;
							ii++;
							continue;
						 }
                        if (max_num_2 - min_num_2 > 0 &&  (double)(min_num_2 + max_num_2) / 2 == mid )
						{
							temp_begin_flags[ii] = temp_begin_flags[ii] + 2;
						}
						else if (max_num_2 - min_num_2 == 0 && (double)(min_num_2 + max_num_2) / 2 == mid)
						{
							temp_begin_flags[ii] = temp_begin_flags[ii] + 1;
							j = 1;
							ii++;
						}
						else if (max_num_2 - min_num_2 < 0)
						{
							j = 1;
							ii++;
							mid2 = mid;

						}
						else
						{
							break;
						}

					}

					if (ii == 26)  // every letter was traversed . palindrome.
					{
						count_number++;
						int begin_temp = s0[begin_number] - 'a';
						char char_temp = s0[begin_number];
						begin_number = a_nums[begin_temp][max_num_addr];
						begin_flags = temp_begin_flags;
						int pos = 0;
						for (size_t iii = 0; iii < begin_number; iii++)
						{
							if (char_temp == s0[iii])
							{
								pos++;
							}
						}
						begin_flags[begin_temp] = pos;
						flag_break = true;
						break;
					}
					else
					{
						max_num_addr--;
						string s_temp = s0.substr(a_nums[s0[begin_number] - 'a'][max_num_addr], a_nums[s0[begin_number] - 'a'][max_num_addr + 1] - a_nums[s0[begin_number] - 'a'][max_num_addr]);

						cout << "sss" << endl;
						cout << s_temp << endl;
						for (size_t i = 0; i < s_temp.length(); i++)
						{
							end_flags[s_temp[i] - 'a'] = end_flags[s_temp[i] - 'a'] + 1;
						}
						j = 1;
					}

					if (flag_break)
					{
						break;
					}

				}

			}
			temp_count.push_back(count_number);
		}
		int count_end;
		if (temp_count[0] > temp_count[1])
		{
			count_end = temp_count[1] - 1;
		}
		else
		{
			count_end = temp_count[0] - 1;
		}
		return count_end;

    }
};
